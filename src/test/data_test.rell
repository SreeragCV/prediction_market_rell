@test module;

import main.{ poll, poll_option, vote, vote_count, user, add_user, create_poll, vote_on_poll_option, add_right_answer, get_poll_results, get_all_polls, get_poll_options };
import lib.ft4.test.utils.{ ft_auth_operation_for };

import lib.ft4.auth;
import acc:lib.ft4.accounts;

val alice = rell.test.pubkeys.alice;
val bob = rell.test.pubkeys.bob;

val aliceKeyPair = rell.test.keypairs.alice;
val bobKeyPair = rell.test.keypairs.bob;



// Utility function to create a poll
function create_test_poll(
    creator_pub_key: byte_array,
    title: text,
    options: list<text>,
    poll_end: integer
): integer {
    val title_image = "http://example.com/image.jpg";

    rell.test.tx()
        .op(ft_auth_operation_for(creator_pub_key))
        .op(create_poll(title, options, poll_end, title_image))
        .sign(aliceKeyPair)
        .run();

    var all_poll = poll @* { } ( @sort_desc .id );
    return all_poll[0];
}

// Utility function to create a poll
function create_test_poll_bob(
    creator_pub_key: byte_array,
    title: text,
    options: list<text>,
    poll_end: integer
): integer {
    val title_image = "http://example.com/image.jpg";

    rell.test.tx()
        .op(ft_auth_operation_for(creator_pub_key))
        .op(create_poll(title, options, poll_end, title_image))
        .sign(bobKeyPair)
        .run();

    var all_poll = poll @* { } ( @sort_desc .id );
    return all_poll[0];
}

// ADD USER - SUCCESS
function test_add_user() {
    rell.test.tx()
        .op(add_user(bob))
        .sign(bobKeyPair)
        .run();

    rell.test.tx()
        .op(add_user(alice))
        .sign(aliceKeyPair)
        .run();

    assert_equals(user @ { } ( @sum 1 ), 2);
}

// CREATE POLL - FAILURE - CANNOT IMPERSONATE USER
function test_create_poll_failure_impersonate_user() {
    val title = "Test Poll";
    val options = ["Option 1", "Option 2", "Option 3"];
    val poll_end = 86400;
    val title_image = "http://example.com/image.jpg";

    test_add_user();

    val f1 = rell.test.tx()
        .op(ft_auth_operation_for(bob))
        .op(create_poll(title, options, poll_end, title_image))
        .sign(aliceKeyPair)
        .run_must_fail();

    assert_true(f1.message.contains("The auth descriptor signer did not sign the transaction."));
}

// CREATE POLL - FAILURE - USER DOES NOT EXIST TO CREATE POLL
function test_create_poll_failure_user_doesnt_exist() {
    val title = "Test Poll";
    val options = ["Option 1", "Option 2", "Option 3"];
    val poll_end = 86400;
    val title_image = "http://example.com/image.jpg";

    rell.test.tx()
        .op(add_user(bob))
        .sign(bobKeyPair)
        .run();

    val f1 = rell.test.tx()
        .op(create_poll(title, options, poll_end, title_image))
        .sign(aliceKeyPair)
        .run_must_fail();

    assert_true(f1.message.contains("Expected at least two operations"));
}

// CREATE POLL - FAILURE - NO OPTIONS PRESENT
function test_create_poll_failure_no_options() {
    val title = "Test Poll";
    val options = list<text>();
    val poll_end = 86400;
    val title_image = "http://example.com/image.jpg";

    test_add_user();

    val f1 = rell.test.tx()
        .op(ft_auth_operation_for(bob))
        .op(create_poll(title, options, poll_end, title_image))
        .sign(bobKeyPair)
        .run_must_fail();

    assert_true(f1.message.contains("At least one option is required"));
}

// CREATE POLL - FAILURE - NO TITLE PRESENT
function test_create_poll_failure_no_title() {
    val title = "";
    val options = list<text>();
    val poll_end = 86400;
    val title_image = "http://example.com/image.jpg";

    test_add_user();

    val f1 = rell.test.tx()
        .op(ft_auth_operation_for(bob))
        .op(create_poll(title, options, poll_end, title_image))
        .sign(bobKeyPair)
        .run_must_fail();

    assert_true(f1.message.contains("title cannot be empty"));
}

// CREATE POLL - SUCCESS
function test_create_poll_success() {
    val title = "Test Poll";
    val options = ["First Creation Option1", "First Creation Option2"];
    val poll_end = 86400;
    val title_image = "http://example.com/image.jpg";

    val title2 = "Test Poll2";
    val options2 = ["Second Creation Option1", "Second Creation Option1"];
    val poll_end2 = 86400;
    val title_image2 = "http://example2.com/image.jpg";

    test_add_user();

    rell.test.tx()
        .op(ft_auth_operation_for(alice))
        .op(create_poll(title, options, poll_end, title_image))
        .sign(aliceKeyPair)
        .run();

    rell.test.tx()
        .op(ft_auth_operation_for(bob))
        .op(create_poll(title2, options2, poll_end2, title_image2))
        .sign(bobKeyPair)
        .run();

    val created_poll = get_all_polls();
    
    // TOTAL POLLS
    assert_equals(poll @ { } ( @sum 1 ), 2);

    // VERIFYING ADDED POLLS
    assert_equals(created_poll[0].id, 1);
    assert_equals(created_poll[0].title, title);
    assert_equals(created_poll[0].poll_end, poll_end);
    assert_equals(created_poll[0].title_image, title_image);
    assert_equals(created_poll[0].data.right_answer, 0);
    assert_equals(created_poll[0].data.is_resolved, false);

    assert_equals(created_poll[1].id, 2);
    assert_equals(created_poll[1].title, title2);
    assert_equals(created_poll[1].poll_end, poll_end2);
    assert_equals(created_poll[1].title_image, title_image2);
    assert_equals(created_poll[1].data.right_answer, 0);
    assert_equals(created_poll[1].data.is_resolved, false);
  
}

// ADD VOTE - SUCCESS
function test_vote_on_poll_option() {
 

    test_create_poll_success();

    rell.test.tx()
        .op(ft_auth_operation_for(bob))
        .op(vote_on_poll_option(1))
        .sign(bobKeyPair)
        .run();

    val get_vote_count = get_poll_results(1);
    print(get_vote_count[0].votes);
    var total_yes_vote = get_vote_count[0].votes;
    assert_equals(total_yes_vote, 1);
}

function test_double_voting() {
    test_add_user();
    val poll_id = create_test_poll(alice, "Double Voting Test", ["Option 1", "Option 2"], 86400);
    
    // First vote (should succeed)
    rell.test.tx()
        .op(ft_auth_operation_for(bob))
        .op(vote_on_poll_option(1))
        .sign(bobKeyPair)
        .run();
    
    // Second vote (should fail)
    val f1 = rell.test.tx()
        .op(ft_auth_operation_for(bob))
        .op(vote_on_poll_option(1))
        .sign(bobKeyPair)
        .run_must_fail();


    assert_true(f1.message.contains("Transaction already in database"));
}

// Test voting on non-existent poll option
function test_vote_on_non_existent_option() {
    test_add_user();
    create_test_poll(alice, "Non-existent Option Test", ["Option 1"], 86400);

    val f1 = rell.test.tx()
        .op(ft_auth_operation_for(bob))
        .op(vote_on_poll_option(999))
        .sign(bobKeyPair)
        .run_must_fail();

    assert_true(f1.message.contains("Poll option does not exist"));
}

//Test adding right answer
function test_add_right_answer() {
    test_add_user();
    val poll_id = create_test_poll(alice, "Right Answer Test", ["Option 1", "Option 2"], 0);

    rell.test.tx()
        .op(ft_auth_operation_for(bob))
        .op(add_right_answer(poll_id, 1))
        .sign(bobKeyPair)
        .run();

    val updated_poll = poll @ { .id == poll_id };
    assert_equals(updated_poll.right_answer, 1);
    assert_equals(updated_poll.is_resolved, true);
}

// Test getting poll options for non-existent poll
function test_get_poll_options_non_existent() {
    val options = get_poll_options(999);
    assert_equals(options.size(), 0);
}

// Test creating poll with maximum number of options
function test_create_poll_max_options() {
    test_add_user();
    val max_options = ["Option ", "Option ", "Option ", "Option ", "Option "]; // Assuming max is 10 options
    val poll_id = create_test_poll(alice, "Max Options Test", max_options, 86400);

    val created_options = get_poll_options(poll_id);
    assert_equals(created_options.size(), max_options.size());
}

// Test poll results accuracy
function test_poll_results_accuracy() {
    test_add_user();
    val poll_id = create_test_poll(alice, "Results Accuracy Test", ["Option 1", "Option 2"], 86400);

    rell.test.tx()
        .op(ft_auth_operation_for(bob))
        .op(vote_on_poll_option(1))
        .sign(bobKeyPair)
        .run();

    rell.test.tx()
        .op(ft_auth_operation_for(alice))
        .op(vote_on_poll_option(2))
        .sign(aliceKeyPair)
        .run();

    val results = get_poll_results(poll_id);
    assert_equals(results[0].votes, 1);
    assert_equals(results[1].votes, 1);
}

// Test poll lifecycle
function test_poll_lifecycle() {
    test_add_user();
    val poll_id = create_test_poll(alice, "Lifecycle Test", ["Option 1", "Option 2"], 0);

    rell.test.tx()
        .op(ft_auth_operation_for(bob))
        .op(vote_on_poll_option(1))
        .sign(bobKeyPair)
        .run();

    rell.test.tx()
        .op(ft_auth_operation_for(alice))
        .op(add_right_answer(poll_id, 1))
        .sign(aliceKeyPair)
        .run();

    val updated_poll = poll @ { .id == poll_id };
    assert_equals(updated_poll.is_resolved, true);
    assert_equals(updated_poll.right_answer, 1);
}

//Test get_all_polls with no polls
function test_get_all_polls_empty() {
    val polls = get_all_polls();
    assert_equals(polls.size(), 0);
}

// Test voting on all options of a poll
function test_vote_all_options() {
    test_add_user();
    val poll_id = create_test_poll(alice, "Vote All Options Test", ["Option 1", "Option 2", "Option 3"], 86400);

    rell.test.tx()
        .op(ft_auth_operation_for(bob))
        .op(vote_on_poll_option(1))
        .sign(bobKeyPair)
        .run();

    rell.test.tx()
        .op(ft_auth_operation_for(alice))
        .op(vote_on_poll_option(2))
        .sign(aliceKeyPair)
        .run();

    rell.test.tx()
        .op(ft_auth_operation_for(alice))
        .op(vote_on_poll_option(3))
        .sign(aliceKeyPair)
        .run();

    val results = get_poll_results(poll_id);
    assert_equals(results.size(), 3);
    assert_equals(results[0].votes + results[1].votes, 2);
}

// Test adding right answer for non-existent poll
function test_add_right_answer_non_existent_poll() {
    test_add_user();

    val f1 = rell.test.tx()
        .op(ft_auth_operation_for(alice))
        .op(add_right_answer(999, 1))
        .sign(aliceKeyPair)
        .run_must_fail();

    assert_true(f1.message.contains("No records found"));
}

// Test creating a poll with no end time (ongoing poll)
function test_create_ongoing_poll() {
    test_add_user();
    val poll_id = create_test_poll(alice, "Ongoing Poll Test", ["Option 1", "Option 2"], 0);

    val created_poll = poll @ { .id == poll_id };
    assert_equals(created_poll.poll_end, 0);
    
    // Ensure voting is still possible
    rell.test.tx()
        .op(ft_auth_operation_for(bob))
        .op(vote_on_poll_option(1))
        .sign(bobKeyPair)
        .run();

    val results = get_poll_results(poll_id);
    assert_equals(results[0].votes, 1);
}

// Test retrieving polls by creator
function test_get_polls_by_creator() {
    test_add_user();
    create_test_poll(alice, "Alice's Poll", ["Option 1", "Option 2"], 86400);
    create_test_poll_bob(bob, "Bob's Poll", ["Option A", "Option B"], 86400);

    var ac = user @* {  }(.account);

    print(ac[0].id,"this ");
    // val alice_polls = poll @ { .creator == acc.account @ { .id == alice } };
    //val bob_polls = poll @ { .creator == acc.account @ { .id == bob } };
    
    
    //assert_equals(alice_polls.title, "Alice's Poll");
    //assert_equals(bob_polls.title, "Bob's Poll");
}
